Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ERROR

Grammar

Rule 0     S' -> program
Rule 1     program -> declist MAIN LRB RRB block
Rule 2     declist -> dec
Rule 3     declist -> declist dec
Rule 4     declist -> <empty>
Rule 5     dec -> vardec
Rule 6     dec -> funcdec
Rule 7     type -> INTEGER
Rule 8     type -> FLOAT
Rule 9     type -> BOOLEAN
Rule 10    iddec -> ID
Rule 11    iddec -> ID LSB exp RSB
Rule 12    iddec -> ID ASSIGN exp
Rule 13    idlist -> iddec
Rule 14    idlist -> idlist COMMA iddec
Rule 15    vardec -> type idlist SEMICOLON
Rule 16    funcdec -> type ID LRB paramdecs RRB block
Rule 17    funcdec -> VOID ID LRB paramdecs RRB block
Rule 18    paramdecs -> paramdecslist
Rule 19    paramdecs -> <empty>
Rule 20    paramdecslist -> paramdec
Rule 21    paramdecslist -> paramdecslist COMMA paramdec
Rule 22    paramdec -> type ID
Rule 23    paramdec -> type ID LSB RSB
Rule 24    varlist -> vardec
Rule 25    varlist -> varlist vardec
Rule 26    varlist -> <empty>
Rule 27    block -> LCB varlist stmtlist RCB
Rule 28    stmtlist -> stmt
Rule 29    stmtlist -> stmtlist stmt
Rule 30    stmtlist -> <empty>
Rule 31    lvalue -> ID
Rule 32    lvalue -> ID LSB exp RSB
Rule 33    stmt -> RETURN exp SEMICOLON
Rule 34    stmt -> exp SEMICOLON
Rule 35    stmt -> block
Rule 36    stmt -> WHILE LRB exp RRB stmt
Rule 37    stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt
Rule 38    stmt -> IF LRB exp RRB stmt elseiflist
Rule 39    stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt
Rule 40    stmt -> PRINT LRB ID RRB SEMICOLON
Rule 41    elseiflist -> ELIF LRB exp RRB stmt
Rule 42    elseiflist -> elseiflist ELIF LRB exp RRB stmt
Rule 43    elseiflist -> <empty>
Rule 44    exp -> lvalue ASSIGN exp
Rule 45    exp -> exp operator exp
Rule 46    exp -> exp relop exp
Rule 47    exp -> const
Rule 48    exp -> lvalue
Rule 49    exp -> ID LRB explist RRB
Rule 50    exp -> LRB exp RRB
Rule 51    exp -> ID LRB RRB
Rule 52    exp -> SUB exp
Rule 53    exp -> NOT exp
Rule 54    operator -> OR
Rule 55    operator -> AND
Rule 56    operator -> SUM
Rule 57    operator -> SUB
Rule 58    operator -> MUL
Rule 59    operator -> DIV
Rule 60    operator -> MOD
Rule 61    const -> INTEGERNUMBER
Rule 62    const -> FLOATNUMBER
Rule 63    const -> TRUE
Rule 64    const -> FALSE
Rule 65    relop -> GT
Rule 66    relop -> LT
Rule 67    relop -> NE
Rule 68    relop -> EQ
Rule 69    relop -> LE
Rule 70    relop -> GE
Rule 71    explist -> exp
Rule 72    explist -> explist COMMA exp

Terminals, with rules where they appear

AND                  : 55
ASSIGN               : 12 44
BOOLEAN              : 9
COMMA                : 14 21 72
DIV                  : 59
ELIF                 : 41 42
ELSE                 : 39
EQ                   : 68
ERROR                : 
FALSE                : 64
FLOAT                : 8
FLOATNUMBER          : 62
FOR                  : 37
GE                   : 70
GT                   : 65
ID                   : 10 11 12 16 17 22 23 31 32 40 49 51
IF                   : 38 39
INTEGER              : 7
INTEGERNUMBER        : 61
LCB                  : 27
LE                   : 69
LRB                  : 1 16 17 36 37 38 39 40 41 42 49 50 51
LSB                  : 11 23 32
LT                   : 66
MAIN                 : 1
MOD                  : 60
MUL                  : 58
NE                   : 67
NOT                  : 53
OR                   : 54
PRINT                : 40
RCB                  : 27
RETURN               : 33
RRB                  : 1 16 17 36 37 38 39 40 41 42 49 50 51
RSB                  : 11 23 32
SEMICOLON            : 15 33 34 37 37 40
SUB                  : 52 57
SUM                  : 56
TRUE                 : 63
VOID                 : 17
WHILE                : 36
error                : 

Nonterminals, with rules where they appear

block                : 1 16 17 35
const                : 47
dec                  : 2 3
declist              : 1 3
elseiflist           : 38 39 42
exp                  : 11 12 32 33 34 36 37 37 37 38 39 41 42 44 45 45 46 46 50 52 53 71 72
explist              : 49 72
funcdec              : 6
iddec                : 13 14
idlist               : 14 15
lvalue               : 44 48
operator             : 45
paramdec             : 20 21
paramdecs            : 16 17
paramdecslist        : 18 21
program              : 0
relop                : 46
stmt                 : 28 29 36 37 38 39 39 41 42
stmtlist             : 27 29
type                 : 15 16 22 23
vardec               : 5 24 25
varlist              : 25 27

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declist MAIN LRB RRB block
    (2) declist -> . dec
    (3) declist -> . declist dec
    (4) declist -> .
    (5) dec -> . vardec
    (6) dec -> . funcdec
    (15) vardec -> . type idlist SEMICOLON
    (16) funcdec -> . type ID LRB paramdecs RRB block
    (17) funcdec -> . VOID ID LRB paramdecs RRB block
    (7) type -> . INTEGER
    (8) type -> . FLOAT
    (9) type -> . BOOLEAN

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    MAIN            reduce using rule 4 (declist -> .)
    VOID            shift and go to state 7
    INTEGER         shift and go to state 8
    FLOAT           shift and go to state 9
    BOOLEAN         shift and go to state 10

  ! VOID            [ reduce using rule 4 (declist -> .) ]
  ! INTEGER         [ reduce using rule 4 (declist -> .) ]
  ! FLOAT           [ reduce using rule 4 (declist -> .) ]
  ! BOOLEAN         [ reduce using rule 4 (declist -> .) ]

    program                        shift and go to state 1
    declist                        shift and go to state 2
    dec                            shift and go to state 3
    vardec                         shift and go to state 4
    funcdec                        shift and go to state 5
    type                           shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> declist . MAIN LRB RRB block
    (3) declist -> declist . dec
    (5) dec -> . vardec
    (6) dec -> . funcdec
    (15) vardec -> . type idlist SEMICOLON
    (16) funcdec -> . type ID LRB paramdecs RRB block
    (17) funcdec -> . VOID ID LRB paramdecs RRB block
    (7) type -> . INTEGER
    (8) type -> . FLOAT
    (9) type -> . BOOLEAN

    MAIN            shift and go to state 11
    VOID            shift and go to state 7
    INTEGER         shift and go to state 8
    FLOAT           shift and go to state 9
    BOOLEAN         shift and go to state 10

    dec                            shift and go to state 12
    vardec                         shift and go to state 4
    funcdec                        shift and go to state 5
    type                           shift and go to state 6

state 3

    (2) declist -> dec .

    MAIN            reduce using rule 2 (declist -> dec .)
    VOID            reduce using rule 2 (declist -> dec .)
    INTEGER         reduce using rule 2 (declist -> dec .)
    FLOAT           reduce using rule 2 (declist -> dec .)
    BOOLEAN         reduce using rule 2 (declist -> dec .)


state 4

    (5) dec -> vardec .

    MAIN            reduce using rule 5 (dec -> vardec .)
    VOID            reduce using rule 5 (dec -> vardec .)
    INTEGER         reduce using rule 5 (dec -> vardec .)
    FLOAT           reduce using rule 5 (dec -> vardec .)
    BOOLEAN         reduce using rule 5 (dec -> vardec .)


state 5

    (6) dec -> funcdec .

    MAIN            reduce using rule 6 (dec -> funcdec .)
    VOID            reduce using rule 6 (dec -> funcdec .)
    INTEGER         reduce using rule 6 (dec -> funcdec .)
    FLOAT           reduce using rule 6 (dec -> funcdec .)
    BOOLEAN         reduce using rule 6 (dec -> funcdec .)


state 6

    (15) vardec -> type . idlist SEMICOLON
    (16) funcdec -> type . ID LRB paramdecs RRB block
    (13) idlist -> . iddec
    (14) idlist -> . idlist COMMA iddec
    (10) iddec -> . ID
    (11) iddec -> . ID LSB exp RSB
    (12) iddec -> . ID ASSIGN exp

    ID              shift and go to state 14

    idlist                         shift and go to state 13
    iddec                          shift and go to state 15

state 7

    (17) funcdec -> VOID . ID LRB paramdecs RRB block

    ID              shift and go to state 16


state 8

    (7) type -> INTEGER .

    ID              reduce using rule 7 (type -> INTEGER .)


state 9

    (8) type -> FLOAT .

    ID              reduce using rule 8 (type -> FLOAT .)


state 10

    (9) type -> BOOLEAN .

    ID              reduce using rule 9 (type -> BOOLEAN .)


state 11

    (1) program -> declist MAIN . LRB RRB block

    LRB             shift and go to state 17


state 12

    (3) declist -> declist dec .

    MAIN            reduce using rule 3 (declist -> declist dec .)
    VOID            reduce using rule 3 (declist -> declist dec .)
    INTEGER         reduce using rule 3 (declist -> declist dec .)
    FLOAT           reduce using rule 3 (declist -> declist dec .)
    BOOLEAN         reduce using rule 3 (declist -> declist dec .)


state 13

    (15) vardec -> type idlist . SEMICOLON
    (14) idlist -> idlist . COMMA iddec

    SEMICOLON       shift and go to state 18
    COMMA           shift and go to state 19


state 14

    (16) funcdec -> type ID . LRB paramdecs RRB block
    (10) iddec -> ID .
    (11) iddec -> ID . LSB exp RSB
    (12) iddec -> ID . ASSIGN exp

    LRB             shift and go to state 20
    SEMICOLON       reduce using rule 10 (iddec -> ID .)
    COMMA           reduce using rule 10 (iddec -> ID .)
    LSB             shift and go to state 21
    ASSIGN          shift and go to state 22


state 15

    (13) idlist -> iddec .

    SEMICOLON       reduce using rule 13 (idlist -> iddec .)
    COMMA           reduce using rule 13 (idlist -> iddec .)


state 16

    (17) funcdec -> VOID ID . LRB paramdecs RRB block

    LRB             shift and go to state 23


state 17

    (1) program -> declist MAIN LRB . RRB block

    RRB             shift and go to state 24


state 18

    (15) vardec -> type idlist SEMICOLON .

    MAIN            reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    VOID            reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    INTEGER         reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    FLOAT           reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    BOOLEAN         reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    RETURN          reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    WHILE           reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    FOR             reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    IF              reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    PRINT           reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    ID              reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    LRB             reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    SUB             reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    NOT             reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    LCB             reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    INTEGERNUMBER   reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    FLOATNUMBER     reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    TRUE            reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    FALSE           reduce using rule 15 (vardec -> type idlist SEMICOLON .)
    RCB             reduce using rule 15 (vardec -> type idlist SEMICOLON .)


state 19

    (14) idlist -> idlist COMMA . iddec
    (10) iddec -> . ID
    (11) iddec -> . ID LSB exp RSB
    (12) iddec -> . ID ASSIGN exp

    ID              shift and go to state 26

    iddec                          shift and go to state 25

state 20

    (16) funcdec -> type ID LRB . paramdecs RRB block
    (18) paramdecs -> . paramdecslist
    (19) paramdecs -> .
    (20) paramdecslist -> . paramdec
    (21) paramdecslist -> . paramdecslist COMMA paramdec
    (22) paramdec -> . type ID
    (23) paramdec -> . type ID LSB RSB
    (7) type -> . INTEGER
    (8) type -> . FLOAT
    (9) type -> . BOOLEAN

    RRB             reduce using rule 19 (paramdecs -> .)
    INTEGER         shift and go to state 8
    FLOAT           shift and go to state 9
    BOOLEAN         shift and go to state 10

    type                           shift and go to state 27
    paramdecs                      shift and go to state 28
    paramdecslist                  shift and go to state 29
    paramdec                       shift and go to state 30

state 21

    (11) iddec -> ID LSB . exp RSB
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 32
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 22

    (12) iddec -> ID ASSIGN . exp
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 42
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 23

    (17) funcdec -> VOID ID LRB . paramdecs RRB block
    (18) paramdecs -> . paramdecslist
    (19) paramdecs -> .
    (20) paramdecslist -> . paramdec
    (21) paramdecslist -> . paramdecslist COMMA paramdec
    (22) paramdec -> . type ID
    (23) paramdec -> . type ID LSB RSB
    (7) type -> . INTEGER
    (8) type -> . FLOAT
    (9) type -> . BOOLEAN

    RRB             reduce using rule 19 (paramdecs -> .)
    INTEGER         shift and go to state 8
    FLOAT           shift and go to state 9
    BOOLEAN         shift and go to state 10

    paramdecs                      shift and go to state 43
    paramdecslist                  shift and go to state 29
    paramdec                       shift and go to state 30
    type                           shift and go to state 27

state 24

    (1) program -> declist MAIN LRB RRB . block
    (27) block -> . LCB varlist stmtlist RCB

    LCB             shift and go to state 45

    block                          shift and go to state 44

state 25

    (14) idlist -> idlist COMMA iddec .

    SEMICOLON       reduce using rule 14 (idlist -> idlist COMMA iddec .)
    COMMA           reduce using rule 14 (idlist -> idlist COMMA iddec .)


state 26

    (10) iddec -> ID .
    (11) iddec -> ID . LSB exp RSB
    (12) iddec -> ID . ASSIGN exp

    SEMICOLON       reduce using rule 10 (iddec -> ID .)
    COMMA           reduce using rule 10 (iddec -> ID .)
    LSB             shift and go to state 21
    ASSIGN          shift and go to state 22


state 27

    (22) paramdec -> type . ID
    (23) paramdec -> type . ID LSB RSB

    ID              shift and go to state 46


state 28

    (16) funcdec -> type ID LRB paramdecs . RRB block

    RRB             shift and go to state 47


state 29

    (18) paramdecs -> paramdecslist .
    (21) paramdecslist -> paramdecslist . COMMA paramdec

    RRB             reduce using rule 18 (paramdecs -> paramdecslist .)
    COMMA           shift and go to state 48


state 30

    (20) paramdecslist -> paramdec .

    COMMA           reduce using rule 20 (paramdecslist -> paramdec .)
    RRB             reduce using rule 20 (paramdecslist -> paramdec .)


state 31

    (49) exp -> ID . LRB explist RRB
    (51) exp -> ID . LRB RRB
    (31) lvalue -> ID .
    (32) lvalue -> ID . LSB exp RSB

    LRB             shift and go to state 49
    ASSIGN          reduce using rule 31 (lvalue -> ID .)
    RSB             reduce using rule 31 (lvalue -> ID .)
    OR              reduce using rule 31 (lvalue -> ID .)
    AND             reduce using rule 31 (lvalue -> ID .)
    SUM             reduce using rule 31 (lvalue -> ID .)
    SUB             reduce using rule 31 (lvalue -> ID .)
    MUL             reduce using rule 31 (lvalue -> ID .)
    DIV             reduce using rule 31 (lvalue -> ID .)
    MOD             reduce using rule 31 (lvalue -> ID .)
    GT              reduce using rule 31 (lvalue -> ID .)
    LT              reduce using rule 31 (lvalue -> ID .)
    NE              reduce using rule 31 (lvalue -> ID .)
    EQ              reduce using rule 31 (lvalue -> ID .)
    LE              reduce using rule 31 (lvalue -> ID .)
    GE              reduce using rule 31 (lvalue -> ID .)
    SEMICOLON       reduce using rule 31 (lvalue -> ID .)
    COMMA           reduce using rule 31 (lvalue -> ID .)
    RRB             reduce using rule 31 (lvalue -> ID .)
    LSB             shift and go to state 50


state 32

    (11) iddec -> ID LSB exp . RSB
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    RSB             shift and go to state 51
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 33

    (44) exp -> lvalue . ASSIGN exp
    (48) exp -> lvalue .

    ASSIGN          shift and go to state 67
    RSB             reduce using rule 48 (exp -> lvalue .)
    OR              reduce using rule 48 (exp -> lvalue .)
    AND             reduce using rule 48 (exp -> lvalue .)
    SUM             reduce using rule 48 (exp -> lvalue .)
    SUB             reduce using rule 48 (exp -> lvalue .)
    MUL             reduce using rule 48 (exp -> lvalue .)
    DIV             reduce using rule 48 (exp -> lvalue .)
    MOD             reduce using rule 48 (exp -> lvalue .)
    GT              reduce using rule 48 (exp -> lvalue .)
    LT              reduce using rule 48 (exp -> lvalue .)
    NE              reduce using rule 48 (exp -> lvalue .)
    EQ              reduce using rule 48 (exp -> lvalue .)
    LE              reduce using rule 48 (exp -> lvalue .)
    GE              reduce using rule 48 (exp -> lvalue .)
    SEMICOLON       reduce using rule 48 (exp -> lvalue .)
    COMMA           reduce using rule 48 (exp -> lvalue .)
    RRB             reduce using rule 48 (exp -> lvalue .)


state 34

    (47) exp -> const .

    RSB             reduce using rule 47 (exp -> const .)
    OR              reduce using rule 47 (exp -> const .)
    AND             reduce using rule 47 (exp -> const .)
    SUM             reduce using rule 47 (exp -> const .)
    SUB             reduce using rule 47 (exp -> const .)
    MUL             reduce using rule 47 (exp -> const .)
    DIV             reduce using rule 47 (exp -> const .)
    MOD             reduce using rule 47 (exp -> const .)
    GT              reduce using rule 47 (exp -> const .)
    LT              reduce using rule 47 (exp -> const .)
    NE              reduce using rule 47 (exp -> const .)
    EQ              reduce using rule 47 (exp -> const .)
    LE              reduce using rule 47 (exp -> const .)
    GE              reduce using rule 47 (exp -> const .)
    SEMICOLON       reduce using rule 47 (exp -> const .)
    COMMA           reduce using rule 47 (exp -> const .)
    RRB             reduce using rule 47 (exp -> const .)


state 35

    (50) exp -> LRB . exp RRB
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 68
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 36

    (52) exp -> SUB . exp
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 69
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 37

    (53) exp -> NOT . exp
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 70
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 38

    (61) const -> INTEGERNUMBER .

    RSB             reduce using rule 61 (const -> INTEGERNUMBER .)
    OR              reduce using rule 61 (const -> INTEGERNUMBER .)
    AND             reduce using rule 61 (const -> INTEGERNUMBER .)
    SUM             reduce using rule 61 (const -> INTEGERNUMBER .)
    SUB             reduce using rule 61 (const -> INTEGERNUMBER .)
    MUL             reduce using rule 61 (const -> INTEGERNUMBER .)
    DIV             reduce using rule 61 (const -> INTEGERNUMBER .)
    MOD             reduce using rule 61 (const -> INTEGERNUMBER .)
    GT              reduce using rule 61 (const -> INTEGERNUMBER .)
    LT              reduce using rule 61 (const -> INTEGERNUMBER .)
    NE              reduce using rule 61 (const -> INTEGERNUMBER .)
    EQ              reduce using rule 61 (const -> INTEGERNUMBER .)
    LE              reduce using rule 61 (const -> INTEGERNUMBER .)
    GE              reduce using rule 61 (const -> INTEGERNUMBER .)
    SEMICOLON       reduce using rule 61 (const -> INTEGERNUMBER .)
    COMMA           reduce using rule 61 (const -> INTEGERNUMBER .)
    RRB             reduce using rule 61 (const -> INTEGERNUMBER .)


state 39

    (62) const -> FLOATNUMBER .

    RSB             reduce using rule 62 (const -> FLOATNUMBER .)
    OR              reduce using rule 62 (const -> FLOATNUMBER .)
    AND             reduce using rule 62 (const -> FLOATNUMBER .)
    SUM             reduce using rule 62 (const -> FLOATNUMBER .)
    SUB             reduce using rule 62 (const -> FLOATNUMBER .)
    MUL             reduce using rule 62 (const -> FLOATNUMBER .)
    DIV             reduce using rule 62 (const -> FLOATNUMBER .)
    MOD             reduce using rule 62 (const -> FLOATNUMBER .)
    GT              reduce using rule 62 (const -> FLOATNUMBER .)
    LT              reduce using rule 62 (const -> FLOATNUMBER .)
    NE              reduce using rule 62 (const -> FLOATNUMBER .)
    EQ              reduce using rule 62 (const -> FLOATNUMBER .)
    LE              reduce using rule 62 (const -> FLOATNUMBER .)
    GE              reduce using rule 62 (const -> FLOATNUMBER .)
    SEMICOLON       reduce using rule 62 (const -> FLOATNUMBER .)
    COMMA           reduce using rule 62 (const -> FLOATNUMBER .)
    RRB             reduce using rule 62 (const -> FLOATNUMBER .)


state 40

    (63) const -> TRUE .

    RSB             reduce using rule 63 (const -> TRUE .)
    OR              reduce using rule 63 (const -> TRUE .)
    AND             reduce using rule 63 (const -> TRUE .)
    SUM             reduce using rule 63 (const -> TRUE .)
    SUB             reduce using rule 63 (const -> TRUE .)
    MUL             reduce using rule 63 (const -> TRUE .)
    DIV             reduce using rule 63 (const -> TRUE .)
    MOD             reduce using rule 63 (const -> TRUE .)
    GT              reduce using rule 63 (const -> TRUE .)
    LT              reduce using rule 63 (const -> TRUE .)
    NE              reduce using rule 63 (const -> TRUE .)
    EQ              reduce using rule 63 (const -> TRUE .)
    LE              reduce using rule 63 (const -> TRUE .)
    GE              reduce using rule 63 (const -> TRUE .)
    SEMICOLON       reduce using rule 63 (const -> TRUE .)
    COMMA           reduce using rule 63 (const -> TRUE .)
    RRB             reduce using rule 63 (const -> TRUE .)


state 41

    (64) const -> FALSE .

    RSB             reduce using rule 64 (const -> FALSE .)
    OR              reduce using rule 64 (const -> FALSE .)
    AND             reduce using rule 64 (const -> FALSE .)
    SUM             reduce using rule 64 (const -> FALSE .)
    SUB             reduce using rule 64 (const -> FALSE .)
    MUL             reduce using rule 64 (const -> FALSE .)
    DIV             reduce using rule 64 (const -> FALSE .)
    MOD             reduce using rule 64 (const -> FALSE .)
    GT              reduce using rule 64 (const -> FALSE .)
    LT              reduce using rule 64 (const -> FALSE .)
    NE              reduce using rule 64 (const -> FALSE .)
    EQ              reduce using rule 64 (const -> FALSE .)
    LE              reduce using rule 64 (const -> FALSE .)
    GE              reduce using rule 64 (const -> FALSE .)
    SEMICOLON       reduce using rule 64 (const -> FALSE .)
    COMMA           reduce using rule 64 (const -> FALSE .)
    RRB             reduce using rule 64 (const -> FALSE .)


state 42

    (12) iddec -> ID ASSIGN exp .
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    SEMICOLON       reduce using rule 12 (iddec -> ID ASSIGN exp .)
    COMMA           reduce using rule 12 (iddec -> ID ASSIGN exp .)
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 43

    (17) funcdec -> VOID ID LRB paramdecs . RRB block

    RRB             shift and go to state 71


state 44

    (1) program -> declist MAIN LRB RRB block .

    $end            reduce using rule 1 (program -> declist MAIN LRB RRB block .)


state 45

    (27) block -> LCB . varlist stmtlist RCB
    (24) varlist -> . vardec
    (25) varlist -> . varlist vardec
    (26) varlist -> .
    (15) vardec -> . type idlist SEMICOLON
    (7) type -> . INTEGER
    (8) type -> . FLOAT
    (9) type -> . BOOLEAN

  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    RETURN          reduce using rule 26 (varlist -> .)
    WHILE           reduce using rule 26 (varlist -> .)
    FOR             reduce using rule 26 (varlist -> .)
    IF              reduce using rule 26 (varlist -> .)
    PRINT           reduce using rule 26 (varlist -> .)
    ID              reduce using rule 26 (varlist -> .)
    LRB             reduce using rule 26 (varlist -> .)
    SUB             reduce using rule 26 (varlist -> .)
    NOT             reduce using rule 26 (varlist -> .)
    LCB             reduce using rule 26 (varlist -> .)
    INTEGERNUMBER   reduce using rule 26 (varlist -> .)
    FLOATNUMBER     reduce using rule 26 (varlist -> .)
    TRUE            reduce using rule 26 (varlist -> .)
    FALSE           reduce using rule 26 (varlist -> .)
    RCB             reduce using rule 26 (varlist -> .)
    INTEGER         shift and go to state 8
    FLOAT           shift and go to state 9
    BOOLEAN         shift and go to state 10

  ! INTEGER         [ reduce using rule 26 (varlist -> .) ]
  ! FLOAT           [ reduce using rule 26 (varlist -> .) ]
  ! BOOLEAN         [ reduce using rule 26 (varlist -> .) ]

    varlist                        shift and go to state 72
    vardec                         shift and go to state 73
    type                           shift and go to state 74

state 46

    (22) paramdec -> type ID .
    (23) paramdec -> type ID . LSB RSB

    COMMA           reduce using rule 22 (paramdec -> type ID .)
    RRB             reduce using rule 22 (paramdec -> type ID .)
    LSB             shift and go to state 75


state 47

    (16) funcdec -> type ID LRB paramdecs RRB . block
    (27) block -> . LCB varlist stmtlist RCB

    LCB             shift and go to state 45

    block                          shift and go to state 76

state 48

    (21) paramdecslist -> paramdecslist COMMA . paramdec
    (22) paramdec -> . type ID
    (23) paramdec -> . type ID LSB RSB
    (7) type -> . INTEGER
    (8) type -> . FLOAT
    (9) type -> . BOOLEAN

    INTEGER         shift and go to state 8
    FLOAT           shift and go to state 9
    BOOLEAN         shift and go to state 10

    paramdec                       shift and go to state 77
    type                           shift and go to state 27

state 49

    (49) exp -> ID LRB . explist RRB
    (51) exp -> ID LRB . RRB
    (71) explist -> . exp
    (72) explist -> . explist COMMA exp
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    RRB             shift and go to state 79
    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    explist                        shift and go to state 78
    exp                            shift and go to state 80
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 50

    (32) lvalue -> ID LSB . exp RSB
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 81
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 51

    (11) iddec -> ID LSB exp RSB .

    SEMICOLON       reduce using rule 11 (iddec -> ID LSB exp RSB .)
    COMMA           reduce using rule 11 (iddec -> ID LSB exp RSB .)


state 52

    (45) exp -> exp operator . exp
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 82
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 53

    (46) exp -> exp relop . exp
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 83
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 54

    (54) operator -> OR .

    ID              reduce using rule 54 (operator -> OR .)
    LRB             reduce using rule 54 (operator -> OR .)
    SUB             reduce using rule 54 (operator -> OR .)
    NOT             reduce using rule 54 (operator -> OR .)
    INTEGERNUMBER   reduce using rule 54 (operator -> OR .)
    FLOATNUMBER     reduce using rule 54 (operator -> OR .)
    TRUE            reduce using rule 54 (operator -> OR .)
    FALSE           reduce using rule 54 (operator -> OR .)


state 55

    (55) operator -> AND .

    ID              reduce using rule 55 (operator -> AND .)
    LRB             reduce using rule 55 (operator -> AND .)
    SUB             reduce using rule 55 (operator -> AND .)
    NOT             reduce using rule 55 (operator -> AND .)
    INTEGERNUMBER   reduce using rule 55 (operator -> AND .)
    FLOATNUMBER     reduce using rule 55 (operator -> AND .)
    TRUE            reduce using rule 55 (operator -> AND .)
    FALSE           reduce using rule 55 (operator -> AND .)


state 56

    (56) operator -> SUM .

    ID              reduce using rule 56 (operator -> SUM .)
    LRB             reduce using rule 56 (operator -> SUM .)
    SUB             reduce using rule 56 (operator -> SUM .)
    NOT             reduce using rule 56 (operator -> SUM .)
    INTEGERNUMBER   reduce using rule 56 (operator -> SUM .)
    FLOATNUMBER     reduce using rule 56 (operator -> SUM .)
    TRUE            reduce using rule 56 (operator -> SUM .)
    FALSE           reduce using rule 56 (operator -> SUM .)


state 57

    (57) operator -> SUB .

    ID              reduce using rule 57 (operator -> SUB .)
    LRB             reduce using rule 57 (operator -> SUB .)
    SUB             reduce using rule 57 (operator -> SUB .)
    NOT             reduce using rule 57 (operator -> SUB .)
    INTEGERNUMBER   reduce using rule 57 (operator -> SUB .)
    FLOATNUMBER     reduce using rule 57 (operator -> SUB .)
    TRUE            reduce using rule 57 (operator -> SUB .)
    FALSE           reduce using rule 57 (operator -> SUB .)


state 58

    (58) operator -> MUL .

    ID              reduce using rule 58 (operator -> MUL .)
    LRB             reduce using rule 58 (operator -> MUL .)
    SUB             reduce using rule 58 (operator -> MUL .)
    NOT             reduce using rule 58 (operator -> MUL .)
    INTEGERNUMBER   reduce using rule 58 (operator -> MUL .)
    FLOATNUMBER     reduce using rule 58 (operator -> MUL .)
    TRUE            reduce using rule 58 (operator -> MUL .)
    FALSE           reduce using rule 58 (operator -> MUL .)


state 59

    (59) operator -> DIV .

    ID              reduce using rule 59 (operator -> DIV .)
    LRB             reduce using rule 59 (operator -> DIV .)
    SUB             reduce using rule 59 (operator -> DIV .)
    NOT             reduce using rule 59 (operator -> DIV .)
    INTEGERNUMBER   reduce using rule 59 (operator -> DIV .)
    FLOATNUMBER     reduce using rule 59 (operator -> DIV .)
    TRUE            reduce using rule 59 (operator -> DIV .)
    FALSE           reduce using rule 59 (operator -> DIV .)


state 60

    (60) operator -> MOD .

    ID              reduce using rule 60 (operator -> MOD .)
    LRB             reduce using rule 60 (operator -> MOD .)
    SUB             reduce using rule 60 (operator -> MOD .)
    NOT             reduce using rule 60 (operator -> MOD .)
    INTEGERNUMBER   reduce using rule 60 (operator -> MOD .)
    FLOATNUMBER     reduce using rule 60 (operator -> MOD .)
    TRUE            reduce using rule 60 (operator -> MOD .)
    FALSE           reduce using rule 60 (operator -> MOD .)


state 61

    (65) relop -> GT .

    ID              reduce using rule 65 (relop -> GT .)
    LRB             reduce using rule 65 (relop -> GT .)
    SUB             reduce using rule 65 (relop -> GT .)
    NOT             reduce using rule 65 (relop -> GT .)
    INTEGERNUMBER   reduce using rule 65 (relop -> GT .)
    FLOATNUMBER     reduce using rule 65 (relop -> GT .)
    TRUE            reduce using rule 65 (relop -> GT .)
    FALSE           reduce using rule 65 (relop -> GT .)


state 62

    (66) relop -> LT .

    ID              reduce using rule 66 (relop -> LT .)
    LRB             reduce using rule 66 (relop -> LT .)
    SUB             reduce using rule 66 (relop -> LT .)
    NOT             reduce using rule 66 (relop -> LT .)
    INTEGERNUMBER   reduce using rule 66 (relop -> LT .)
    FLOATNUMBER     reduce using rule 66 (relop -> LT .)
    TRUE            reduce using rule 66 (relop -> LT .)
    FALSE           reduce using rule 66 (relop -> LT .)


state 63

    (67) relop -> NE .

    ID              reduce using rule 67 (relop -> NE .)
    LRB             reduce using rule 67 (relop -> NE .)
    SUB             reduce using rule 67 (relop -> NE .)
    NOT             reduce using rule 67 (relop -> NE .)
    INTEGERNUMBER   reduce using rule 67 (relop -> NE .)
    FLOATNUMBER     reduce using rule 67 (relop -> NE .)
    TRUE            reduce using rule 67 (relop -> NE .)
    FALSE           reduce using rule 67 (relop -> NE .)


state 64

    (68) relop -> EQ .

    ID              reduce using rule 68 (relop -> EQ .)
    LRB             reduce using rule 68 (relop -> EQ .)
    SUB             reduce using rule 68 (relop -> EQ .)
    NOT             reduce using rule 68 (relop -> EQ .)
    INTEGERNUMBER   reduce using rule 68 (relop -> EQ .)
    FLOATNUMBER     reduce using rule 68 (relop -> EQ .)
    TRUE            reduce using rule 68 (relop -> EQ .)
    FALSE           reduce using rule 68 (relop -> EQ .)


state 65

    (69) relop -> LE .

    ID              reduce using rule 69 (relop -> LE .)
    LRB             reduce using rule 69 (relop -> LE .)
    SUB             reduce using rule 69 (relop -> LE .)
    NOT             reduce using rule 69 (relop -> LE .)
    INTEGERNUMBER   reduce using rule 69 (relop -> LE .)
    FLOATNUMBER     reduce using rule 69 (relop -> LE .)
    TRUE            reduce using rule 69 (relop -> LE .)
    FALSE           reduce using rule 69 (relop -> LE .)


state 66

    (70) relop -> GE .

    ID              reduce using rule 70 (relop -> GE .)
    LRB             reduce using rule 70 (relop -> GE .)
    SUB             reduce using rule 70 (relop -> GE .)
    NOT             reduce using rule 70 (relop -> GE .)
    INTEGERNUMBER   reduce using rule 70 (relop -> GE .)
    FLOATNUMBER     reduce using rule 70 (relop -> GE .)
    TRUE            reduce using rule 70 (relop -> GE .)
    FALSE           reduce using rule 70 (relop -> GE .)


state 67

    (44) exp -> lvalue ASSIGN . exp
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    lvalue                         shift and go to state 33
    exp                            shift and go to state 84
    const                          shift and go to state 34

state 68

    (50) exp -> LRB exp . RRB
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    RRB             shift and go to state 85
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 69

    (52) exp -> SUB exp .
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    RSB             reduce using rule 52 (exp -> SUB exp .)
    OR              reduce using rule 52 (exp -> SUB exp .)
    AND             reduce using rule 52 (exp -> SUB exp .)
    SUM             reduce using rule 52 (exp -> SUB exp .)
    SUB             reduce using rule 52 (exp -> SUB exp .)
    MOD             reduce using rule 52 (exp -> SUB exp .)
    GT              reduce using rule 52 (exp -> SUB exp .)
    LT              reduce using rule 52 (exp -> SUB exp .)
    NE              reduce using rule 52 (exp -> SUB exp .)
    EQ              reduce using rule 52 (exp -> SUB exp .)
    LE              reduce using rule 52 (exp -> SUB exp .)
    GE              reduce using rule 52 (exp -> SUB exp .)
    SEMICOLON       reduce using rule 52 (exp -> SUB exp .)
    COMMA           reduce using rule 52 (exp -> SUB exp .)
    RRB             reduce using rule 52 (exp -> SUB exp .)
    MUL             shift and go to state 58
    DIV             shift and go to state 59

  ! MUL             [ reduce using rule 52 (exp -> SUB exp .) ]
  ! DIV             [ reduce using rule 52 (exp -> SUB exp .) ]
  ! OR              [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! SUM             [ shift and go to state 56 ]
  ! SUB             [ shift and go to state 57 ]
  ! MOD             [ shift and go to state 60 ]
  ! GT              [ shift and go to state 61 ]
  ! LT              [ shift and go to state 62 ]
  ! NE              [ shift and go to state 63 ]
  ! EQ              [ shift and go to state 64 ]
  ! LE              [ shift and go to state 65 ]
  ! GE              [ shift and go to state 66 ]

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 70

    (53) exp -> NOT exp .
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    RSB             reduce using rule 53 (exp -> NOT exp .)
    SEMICOLON       reduce using rule 53 (exp -> NOT exp .)
    COMMA           reduce using rule 53 (exp -> NOT exp .)
    RRB             reduce using rule 53 (exp -> NOT exp .)
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

  ! OR              [ reduce using rule 53 (exp -> NOT exp .) ]
  ! AND             [ reduce using rule 53 (exp -> NOT exp .) ]
  ! SUM             [ reduce using rule 53 (exp -> NOT exp .) ]
  ! SUB             [ reduce using rule 53 (exp -> NOT exp .) ]
  ! MUL             [ reduce using rule 53 (exp -> NOT exp .) ]
  ! DIV             [ reduce using rule 53 (exp -> NOT exp .) ]
  ! MOD             [ reduce using rule 53 (exp -> NOT exp .) ]
  ! GT              [ reduce using rule 53 (exp -> NOT exp .) ]
  ! LT              [ reduce using rule 53 (exp -> NOT exp .) ]
  ! NE              [ reduce using rule 53 (exp -> NOT exp .) ]
  ! EQ              [ reduce using rule 53 (exp -> NOT exp .) ]
  ! LE              [ reduce using rule 53 (exp -> NOT exp .) ]
  ! GE              [ reduce using rule 53 (exp -> NOT exp .) ]

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 71

    (17) funcdec -> VOID ID LRB paramdecs RRB . block
    (27) block -> . LCB varlist stmtlist RCB

    LCB             shift and go to state 45

    block                          shift and go to state 86

state 72

    (27) block -> LCB varlist . stmtlist RCB
    (25) varlist -> varlist . vardec
    (28) stmtlist -> . stmt
    (29) stmtlist -> . stmtlist stmt
    (30) stmtlist -> .
    (15) vardec -> . type idlist SEMICOLON
    (33) stmt -> . RETURN exp SEMICOLON
    (34) stmt -> . exp SEMICOLON
    (35) stmt -> . block
    (36) stmt -> . WHILE LRB exp RRB stmt
    (37) stmt -> . FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt
    (38) stmt -> . IF LRB exp RRB stmt elseiflist
    (39) stmt -> . IF LRB exp RRB stmt elseiflist ELSE stmt
    (40) stmt -> . PRINT LRB ID RRB SEMICOLON
    (7) type -> . INTEGER
    (8) type -> . FLOAT
    (9) type -> . BOOLEAN
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (27) block -> . LCB varlist stmtlist RCB
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LRB resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for LCB resolved as shift
  ! shift/reduce conflict for INTEGERNUMBER resolved as shift
  ! shift/reduce conflict for FLOATNUMBER resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    RCB             reduce using rule 30 (stmtlist -> .)
    RETURN          shift and go to state 90
    WHILE           shift and go to state 93
    FOR             shift and go to state 94
    IF              shift and go to state 95
    PRINT           shift and go to state 96
    INTEGER         shift and go to state 8
    FLOAT           shift and go to state 9
    BOOLEAN         shift and go to state 10
    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    LCB             shift and go to state 45
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

  ! RETURN          [ reduce using rule 30 (stmtlist -> .) ]
  ! WHILE           [ reduce using rule 30 (stmtlist -> .) ]
  ! FOR             [ reduce using rule 30 (stmtlist -> .) ]
  ! IF              [ reduce using rule 30 (stmtlist -> .) ]
  ! PRINT           [ reduce using rule 30 (stmtlist -> .) ]
  ! ID              [ reduce using rule 30 (stmtlist -> .) ]
  ! LRB             [ reduce using rule 30 (stmtlist -> .) ]
  ! SUB             [ reduce using rule 30 (stmtlist -> .) ]
  ! NOT             [ reduce using rule 30 (stmtlist -> .) ]
  ! LCB             [ reduce using rule 30 (stmtlist -> .) ]
  ! INTEGERNUMBER   [ reduce using rule 30 (stmtlist -> .) ]
  ! FLOATNUMBER     [ reduce using rule 30 (stmtlist -> .) ]
  ! TRUE            [ reduce using rule 30 (stmtlist -> .) ]
  ! FALSE           [ reduce using rule 30 (stmtlist -> .) ]

    stmtlist                       shift and go to state 87
    vardec                         shift and go to state 88
    stmt                           shift and go to state 89
    type                           shift and go to state 74
    exp                            shift and go to state 91
    block                          shift and go to state 92
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 73

    (24) varlist -> vardec .

    RETURN          reduce using rule 24 (varlist -> vardec .)
    WHILE           reduce using rule 24 (varlist -> vardec .)
    FOR             reduce using rule 24 (varlist -> vardec .)
    IF              reduce using rule 24 (varlist -> vardec .)
    PRINT           reduce using rule 24 (varlist -> vardec .)
    INTEGER         reduce using rule 24 (varlist -> vardec .)
    FLOAT           reduce using rule 24 (varlist -> vardec .)
    BOOLEAN         reduce using rule 24 (varlist -> vardec .)
    ID              reduce using rule 24 (varlist -> vardec .)
    LRB             reduce using rule 24 (varlist -> vardec .)
    SUB             reduce using rule 24 (varlist -> vardec .)
    NOT             reduce using rule 24 (varlist -> vardec .)
    LCB             reduce using rule 24 (varlist -> vardec .)
    INTEGERNUMBER   reduce using rule 24 (varlist -> vardec .)
    FLOATNUMBER     reduce using rule 24 (varlist -> vardec .)
    TRUE            reduce using rule 24 (varlist -> vardec .)
    FALSE           reduce using rule 24 (varlist -> vardec .)
    RCB             reduce using rule 24 (varlist -> vardec .)


state 74

    (15) vardec -> type . idlist SEMICOLON
    (13) idlist -> . iddec
    (14) idlist -> . idlist COMMA iddec
    (10) iddec -> . ID
    (11) iddec -> . ID LSB exp RSB
    (12) iddec -> . ID ASSIGN exp

    ID              shift and go to state 26

    idlist                         shift and go to state 13
    iddec                          shift and go to state 15

state 75

    (23) paramdec -> type ID LSB . RSB

    RSB             shift and go to state 97


state 76

    (16) funcdec -> type ID LRB paramdecs RRB block .

    MAIN            reduce using rule 16 (funcdec -> type ID LRB paramdecs RRB block .)
    VOID            reduce using rule 16 (funcdec -> type ID LRB paramdecs RRB block .)
    INTEGER         reduce using rule 16 (funcdec -> type ID LRB paramdecs RRB block .)
    FLOAT           reduce using rule 16 (funcdec -> type ID LRB paramdecs RRB block .)
    BOOLEAN         reduce using rule 16 (funcdec -> type ID LRB paramdecs RRB block .)


state 77

    (21) paramdecslist -> paramdecslist COMMA paramdec .

    COMMA           reduce using rule 21 (paramdecslist -> paramdecslist COMMA paramdec .)
    RRB             reduce using rule 21 (paramdecslist -> paramdecslist COMMA paramdec .)


state 78

    (49) exp -> ID LRB explist . RRB
    (72) explist -> explist . COMMA exp

    RRB             shift and go to state 98
    COMMA           shift and go to state 99


state 79

    (51) exp -> ID LRB RRB .

    RSB             reduce using rule 51 (exp -> ID LRB RRB .)
    OR              reduce using rule 51 (exp -> ID LRB RRB .)
    AND             reduce using rule 51 (exp -> ID LRB RRB .)
    SUM             reduce using rule 51 (exp -> ID LRB RRB .)
    SUB             reduce using rule 51 (exp -> ID LRB RRB .)
    MUL             reduce using rule 51 (exp -> ID LRB RRB .)
    DIV             reduce using rule 51 (exp -> ID LRB RRB .)
    MOD             reduce using rule 51 (exp -> ID LRB RRB .)
    GT              reduce using rule 51 (exp -> ID LRB RRB .)
    LT              reduce using rule 51 (exp -> ID LRB RRB .)
    NE              reduce using rule 51 (exp -> ID LRB RRB .)
    EQ              reduce using rule 51 (exp -> ID LRB RRB .)
    LE              reduce using rule 51 (exp -> ID LRB RRB .)
    GE              reduce using rule 51 (exp -> ID LRB RRB .)
    SEMICOLON       reduce using rule 51 (exp -> ID LRB RRB .)
    COMMA           reduce using rule 51 (exp -> ID LRB RRB .)
    RRB             reduce using rule 51 (exp -> ID LRB RRB .)


state 80

    (71) explist -> exp .
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    RRB             reduce using rule 71 (explist -> exp .)
    COMMA           reduce using rule 71 (explist -> exp .)
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 81

    (32) lvalue -> ID LSB exp . RSB
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    RSB             shift and go to state 100
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 82

    (45) exp -> exp operator exp .
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    RSB             reduce using rule 45 (exp -> exp operator exp .)
    SEMICOLON       reduce using rule 45 (exp -> exp operator exp .)
    COMMA           reduce using rule 45 (exp -> exp operator exp .)
    RRB             reduce using rule 45 (exp -> exp operator exp .)
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

  ! OR              [ reduce using rule 45 (exp -> exp operator exp .) ]
  ! AND             [ reduce using rule 45 (exp -> exp operator exp .) ]
  ! SUM             [ reduce using rule 45 (exp -> exp operator exp .) ]
  ! SUB             [ reduce using rule 45 (exp -> exp operator exp .) ]
  ! MUL             [ reduce using rule 45 (exp -> exp operator exp .) ]
  ! DIV             [ reduce using rule 45 (exp -> exp operator exp .) ]
  ! MOD             [ reduce using rule 45 (exp -> exp operator exp .) ]
  ! GT              [ reduce using rule 45 (exp -> exp operator exp .) ]
  ! LT              [ reduce using rule 45 (exp -> exp operator exp .) ]
  ! NE              [ reduce using rule 45 (exp -> exp operator exp .) ]
  ! EQ              [ reduce using rule 45 (exp -> exp operator exp .) ]
  ! LE              [ reduce using rule 45 (exp -> exp operator exp .) ]
  ! GE              [ reduce using rule 45 (exp -> exp operator exp .) ]

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 83

    (46) exp -> exp relop exp .
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    RSB             reduce using rule 46 (exp -> exp relop exp .)
    SEMICOLON       reduce using rule 46 (exp -> exp relop exp .)
    COMMA           reduce using rule 46 (exp -> exp relop exp .)
    RRB             reduce using rule 46 (exp -> exp relop exp .)
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

  ! OR              [ reduce using rule 46 (exp -> exp relop exp .) ]
  ! AND             [ reduce using rule 46 (exp -> exp relop exp .) ]
  ! SUM             [ reduce using rule 46 (exp -> exp relop exp .) ]
  ! SUB             [ reduce using rule 46 (exp -> exp relop exp .) ]
  ! MUL             [ reduce using rule 46 (exp -> exp relop exp .) ]
  ! DIV             [ reduce using rule 46 (exp -> exp relop exp .) ]
  ! MOD             [ reduce using rule 46 (exp -> exp relop exp .) ]
  ! GT              [ reduce using rule 46 (exp -> exp relop exp .) ]
  ! LT              [ reduce using rule 46 (exp -> exp relop exp .) ]
  ! NE              [ reduce using rule 46 (exp -> exp relop exp .) ]
  ! EQ              [ reduce using rule 46 (exp -> exp relop exp .) ]
  ! LE              [ reduce using rule 46 (exp -> exp relop exp .) ]
  ! GE              [ reduce using rule 46 (exp -> exp relop exp .) ]

    relop                          shift and go to state 53
    operator                       shift and go to state 52

state 84

    (44) exp -> lvalue ASSIGN exp .
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for SUM resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    RSB             reduce using rule 44 (exp -> lvalue ASSIGN exp .)
    SEMICOLON       reduce using rule 44 (exp -> lvalue ASSIGN exp .)
    COMMA           reduce using rule 44 (exp -> lvalue ASSIGN exp .)
    RRB             reduce using rule 44 (exp -> lvalue ASSIGN exp .)
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

  ! OR              [ reduce using rule 44 (exp -> lvalue ASSIGN exp .) ]
  ! AND             [ reduce using rule 44 (exp -> lvalue ASSIGN exp .) ]
  ! SUM             [ reduce using rule 44 (exp -> lvalue ASSIGN exp .) ]
  ! SUB             [ reduce using rule 44 (exp -> lvalue ASSIGN exp .) ]
  ! MUL             [ reduce using rule 44 (exp -> lvalue ASSIGN exp .) ]
  ! DIV             [ reduce using rule 44 (exp -> lvalue ASSIGN exp .) ]
  ! MOD             [ reduce using rule 44 (exp -> lvalue ASSIGN exp .) ]
  ! GT              [ reduce using rule 44 (exp -> lvalue ASSIGN exp .) ]
  ! LT              [ reduce using rule 44 (exp -> lvalue ASSIGN exp .) ]
  ! NE              [ reduce using rule 44 (exp -> lvalue ASSIGN exp .) ]
  ! EQ              [ reduce using rule 44 (exp -> lvalue ASSIGN exp .) ]
  ! LE              [ reduce using rule 44 (exp -> lvalue ASSIGN exp .) ]
  ! GE              [ reduce using rule 44 (exp -> lvalue ASSIGN exp .) ]

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 85

    (50) exp -> LRB exp RRB .

    RSB             reduce using rule 50 (exp -> LRB exp RRB .)
    OR              reduce using rule 50 (exp -> LRB exp RRB .)
    AND             reduce using rule 50 (exp -> LRB exp RRB .)
    SUM             reduce using rule 50 (exp -> LRB exp RRB .)
    SUB             reduce using rule 50 (exp -> LRB exp RRB .)
    MUL             reduce using rule 50 (exp -> LRB exp RRB .)
    DIV             reduce using rule 50 (exp -> LRB exp RRB .)
    MOD             reduce using rule 50 (exp -> LRB exp RRB .)
    GT              reduce using rule 50 (exp -> LRB exp RRB .)
    LT              reduce using rule 50 (exp -> LRB exp RRB .)
    NE              reduce using rule 50 (exp -> LRB exp RRB .)
    EQ              reduce using rule 50 (exp -> LRB exp RRB .)
    LE              reduce using rule 50 (exp -> LRB exp RRB .)
    GE              reduce using rule 50 (exp -> LRB exp RRB .)
    SEMICOLON       reduce using rule 50 (exp -> LRB exp RRB .)
    COMMA           reduce using rule 50 (exp -> LRB exp RRB .)
    RRB             reduce using rule 50 (exp -> LRB exp RRB .)


state 86

    (17) funcdec -> VOID ID LRB paramdecs RRB block .

    MAIN            reduce using rule 17 (funcdec -> VOID ID LRB paramdecs RRB block .)
    VOID            reduce using rule 17 (funcdec -> VOID ID LRB paramdecs RRB block .)
    INTEGER         reduce using rule 17 (funcdec -> VOID ID LRB paramdecs RRB block .)
    FLOAT           reduce using rule 17 (funcdec -> VOID ID LRB paramdecs RRB block .)
    BOOLEAN         reduce using rule 17 (funcdec -> VOID ID LRB paramdecs RRB block .)


state 87

    (27) block -> LCB varlist stmtlist . RCB
    (29) stmtlist -> stmtlist . stmt
    (33) stmt -> . RETURN exp SEMICOLON
    (34) stmt -> . exp SEMICOLON
    (35) stmt -> . block
    (36) stmt -> . WHILE LRB exp RRB stmt
    (37) stmt -> . FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt
    (38) stmt -> . IF LRB exp RRB stmt elseiflist
    (39) stmt -> . IF LRB exp RRB stmt elseiflist ELSE stmt
    (40) stmt -> . PRINT LRB ID RRB SEMICOLON
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (27) block -> . LCB varlist stmtlist RCB
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    RCB             shift and go to state 101
    RETURN          shift and go to state 90
    WHILE           shift and go to state 93
    FOR             shift and go to state 94
    IF              shift and go to state 95
    PRINT           shift and go to state 96
    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    LCB             shift and go to state 45
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    stmt                           shift and go to state 102
    exp                            shift and go to state 91
    block                          shift and go to state 92
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 88

    (25) varlist -> varlist vardec .

    RETURN          reduce using rule 25 (varlist -> varlist vardec .)
    WHILE           reduce using rule 25 (varlist -> varlist vardec .)
    FOR             reduce using rule 25 (varlist -> varlist vardec .)
    IF              reduce using rule 25 (varlist -> varlist vardec .)
    PRINT           reduce using rule 25 (varlist -> varlist vardec .)
    INTEGER         reduce using rule 25 (varlist -> varlist vardec .)
    FLOAT           reduce using rule 25 (varlist -> varlist vardec .)
    BOOLEAN         reduce using rule 25 (varlist -> varlist vardec .)
    ID              reduce using rule 25 (varlist -> varlist vardec .)
    LRB             reduce using rule 25 (varlist -> varlist vardec .)
    SUB             reduce using rule 25 (varlist -> varlist vardec .)
    NOT             reduce using rule 25 (varlist -> varlist vardec .)
    LCB             reduce using rule 25 (varlist -> varlist vardec .)
    INTEGERNUMBER   reduce using rule 25 (varlist -> varlist vardec .)
    FLOATNUMBER     reduce using rule 25 (varlist -> varlist vardec .)
    TRUE            reduce using rule 25 (varlist -> varlist vardec .)
    FALSE           reduce using rule 25 (varlist -> varlist vardec .)
    RCB             reduce using rule 25 (varlist -> varlist vardec .)


state 89

    (28) stmtlist -> stmt .

    RCB             reduce using rule 28 (stmtlist -> stmt .)
    RETURN          reduce using rule 28 (stmtlist -> stmt .)
    WHILE           reduce using rule 28 (stmtlist -> stmt .)
    FOR             reduce using rule 28 (stmtlist -> stmt .)
    IF              reduce using rule 28 (stmtlist -> stmt .)
    PRINT           reduce using rule 28 (stmtlist -> stmt .)
    ID              reduce using rule 28 (stmtlist -> stmt .)
    LRB             reduce using rule 28 (stmtlist -> stmt .)
    SUB             reduce using rule 28 (stmtlist -> stmt .)
    NOT             reduce using rule 28 (stmtlist -> stmt .)
    LCB             reduce using rule 28 (stmtlist -> stmt .)
    INTEGERNUMBER   reduce using rule 28 (stmtlist -> stmt .)
    FLOATNUMBER     reduce using rule 28 (stmtlist -> stmt .)
    TRUE            reduce using rule 28 (stmtlist -> stmt .)
    FALSE           reduce using rule 28 (stmtlist -> stmt .)


state 90

    (33) stmt -> RETURN . exp SEMICOLON
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 103
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 91

    (34) stmt -> exp . SEMICOLON
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    SEMICOLON       shift and go to state 104
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 92

    (35) stmt -> block .

    RCB             reduce using rule 35 (stmt -> block .)
    RETURN          reduce using rule 35 (stmt -> block .)
    WHILE           reduce using rule 35 (stmt -> block .)
    FOR             reduce using rule 35 (stmt -> block .)
    IF              reduce using rule 35 (stmt -> block .)
    PRINT           reduce using rule 35 (stmt -> block .)
    ID              reduce using rule 35 (stmt -> block .)
    LRB             reduce using rule 35 (stmt -> block .)
    SUB             reduce using rule 35 (stmt -> block .)
    NOT             reduce using rule 35 (stmt -> block .)
    LCB             reduce using rule 35 (stmt -> block .)
    INTEGERNUMBER   reduce using rule 35 (stmt -> block .)
    FLOATNUMBER     reduce using rule 35 (stmt -> block .)
    TRUE            reduce using rule 35 (stmt -> block .)
    FALSE           reduce using rule 35 (stmt -> block .)
    ELIF            reduce using rule 35 (stmt -> block .)
    ELSE            reduce using rule 35 (stmt -> block .)


state 93

    (36) stmt -> WHILE . LRB exp RRB stmt

    LRB             shift and go to state 105


state 94

    (37) stmt -> FOR . LRB exp SEMICOLON exp SEMICOLON exp RRB stmt

    LRB             shift and go to state 106


state 95

    (38) stmt -> IF . LRB exp RRB stmt elseiflist
    (39) stmt -> IF . LRB exp RRB stmt elseiflist ELSE stmt

    LRB             shift and go to state 107


state 96

    (40) stmt -> PRINT . LRB ID RRB SEMICOLON

    LRB             shift and go to state 108


state 97

    (23) paramdec -> type ID LSB RSB .

    COMMA           reduce using rule 23 (paramdec -> type ID LSB RSB .)
    RRB             reduce using rule 23 (paramdec -> type ID LSB RSB .)


state 98

    (49) exp -> ID LRB explist RRB .

    RSB             reduce using rule 49 (exp -> ID LRB explist RRB .)
    OR              reduce using rule 49 (exp -> ID LRB explist RRB .)
    AND             reduce using rule 49 (exp -> ID LRB explist RRB .)
    SUM             reduce using rule 49 (exp -> ID LRB explist RRB .)
    SUB             reduce using rule 49 (exp -> ID LRB explist RRB .)
    MUL             reduce using rule 49 (exp -> ID LRB explist RRB .)
    DIV             reduce using rule 49 (exp -> ID LRB explist RRB .)
    MOD             reduce using rule 49 (exp -> ID LRB explist RRB .)
    GT              reduce using rule 49 (exp -> ID LRB explist RRB .)
    LT              reduce using rule 49 (exp -> ID LRB explist RRB .)
    NE              reduce using rule 49 (exp -> ID LRB explist RRB .)
    EQ              reduce using rule 49 (exp -> ID LRB explist RRB .)
    LE              reduce using rule 49 (exp -> ID LRB explist RRB .)
    GE              reduce using rule 49 (exp -> ID LRB explist RRB .)
    SEMICOLON       reduce using rule 49 (exp -> ID LRB explist RRB .)
    COMMA           reduce using rule 49 (exp -> ID LRB explist RRB .)
    RRB             reduce using rule 49 (exp -> ID LRB explist RRB .)


state 99

    (72) explist -> explist COMMA . exp
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 109
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 100

    (32) lvalue -> ID LSB exp RSB .

    ASSIGN          reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    RSB             reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    OR              reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    AND             reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    SUM             reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    SUB             reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    MUL             reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    DIV             reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    MOD             reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    GT              reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    LT              reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    NE              reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    EQ              reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    LE              reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    GE              reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    SEMICOLON       reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    COMMA           reduce using rule 32 (lvalue -> ID LSB exp RSB .)
    RRB             reduce using rule 32 (lvalue -> ID LSB exp RSB .)


state 101

    (27) block -> LCB varlist stmtlist RCB .

    $end            reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    MAIN            reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    VOID            reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    INTEGER         reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    FLOAT           reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    BOOLEAN         reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    RCB             reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    RETURN          reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    WHILE           reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    FOR             reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    IF              reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    PRINT           reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    ID              reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    LRB             reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    SUB             reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    NOT             reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    LCB             reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    INTEGERNUMBER   reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    FLOATNUMBER     reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    TRUE            reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    FALSE           reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    ELIF            reduce using rule 27 (block -> LCB varlist stmtlist RCB .)
    ELSE            reduce using rule 27 (block -> LCB varlist stmtlist RCB .)


state 102

    (29) stmtlist -> stmtlist stmt .

    RCB             reduce using rule 29 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 29 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 29 (stmtlist -> stmtlist stmt .)
    FOR             reduce using rule 29 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 29 (stmtlist -> stmtlist stmt .)
    PRINT           reduce using rule 29 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 29 (stmtlist -> stmtlist stmt .)
    LRB             reduce using rule 29 (stmtlist -> stmtlist stmt .)
    SUB             reduce using rule 29 (stmtlist -> stmtlist stmt .)
    NOT             reduce using rule 29 (stmtlist -> stmtlist stmt .)
    LCB             reduce using rule 29 (stmtlist -> stmtlist stmt .)
    INTEGERNUMBER   reduce using rule 29 (stmtlist -> stmtlist stmt .)
    FLOATNUMBER     reduce using rule 29 (stmtlist -> stmtlist stmt .)
    TRUE            reduce using rule 29 (stmtlist -> stmtlist stmt .)
    FALSE           reduce using rule 29 (stmtlist -> stmtlist stmt .)


state 103

    (33) stmt -> RETURN exp . SEMICOLON
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    SEMICOLON       shift and go to state 110
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 104

    (34) stmt -> exp SEMICOLON .

    RCB             reduce using rule 34 (stmt -> exp SEMICOLON .)
    RETURN          reduce using rule 34 (stmt -> exp SEMICOLON .)
    WHILE           reduce using rule 34 (stmt -> exp SEMICOLON .)
    FOR             reduce using rule 34 (stmt -> exp SEMICOLON .)
    IF              reduce using rule 34 (stmt -> exp SEMICOLON .)
    PRINT           reduce using rule 34 (stmt -> exp SEMICOLON .)
    ID              reduce using rule 34 (stmt -> exp SEMICOLON .)
    LRB             reduce using rule 34 (stmt -> exp SEMICOLON .)
    SUB             reduce using rule 34 (stmt -> exp SEMICOLON .)
    NOT             reduce using rule 34 (stmt -> exp SEMICOLON .)
    LCB             reduce using rule 34 (stmt -> exp SEMICOLON .)
    INTEGERNUMBER   reduce using rule 34 (stmt -> exp SEMICOLON .)
    FLOATNUMBER     reduce using rule 34 (stmt -> exp SEMICOLON .)
    TRUE            reduce using rule 34 (stmt -> exp SEMICOLON .)
    FALSE           reduce using rule 34 (stmt -> exp SEMICOLON .)
    ELIF            reduce using rule 34 (stmt -> exp SEMICOLON .)
    ELSE            reduce using rule 34 (stmt -> exp SEMICOLON .)


state 105

    (36) stmt -> WHILE LRB . exp RRB stmt
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 111
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 106

    (37) stmt -> FOR LRB . exp SEMICOLON exp SEMICOLON exp RRB stmt
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 112
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 107

    (38) stmt -> IF LRB . exp RRB stmt elseiflist
    (39) stmt -> IF LRB . exp RRB stmt elseiflist ELSE stmt
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 113
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 108

    (40) stmt -> PRINT LRB . ID RRB SEMICOLON

    ID              shift and go to state 114


state 109

    (72) explist -> explist COMMA exp .
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    RRB             reduce using rule 72 (explist -> explist COMMA exp .)
    COMMA           reduce using rule 72 (explist -> explist COMMA exp .)
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 110

    (33) stmt -> RETURN exp SEMICOLON .

    RCB             reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    IF              reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    PRINT           reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    ID              reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    LRB             reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    SUB             reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    NOT             reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    LCB             reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    INTEGERNUMBER   reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    FLOATNUMBER     reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    TRUE            reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    FALSE           reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    ELIF            reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)
    ELSE            reduce using rule 33 (stmt -> RETURN exp SEMICOLON .)


state 111

    (36) stmt -> WHILE LRB exp . RRB stmt
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    RRB             shift and go to state 115
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 112

    (37) stmt -> FOR LRB exp . SEMICOLON exp SEMICOLON exp RRB stmt
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    SEMICOLON       shift and go to state 116
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 113

    (38) stmt -> IF LRB exp . RRB stmt elseiflist
    (39) stmt -> IF LRB exp . RRB stmt elseiflist ELSE stmt
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    RRB             shift and go to state 117
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 114

    (40) stmt -> PRINT LRB ID . RRB SEMICOLON

    RRB             shift and go to state 118


state 115

    (36) stmt -> WHILE LRB exp RRB . stmt
    (33) stmt -> . RETURN exp SEMICOLON
    (34) stmt -> . exp SEMICOLON
    (35) stmt -> . block
    (36) stmt -> . WHILE LRB exp RRB stmt
    (37) stmt -> . FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt
    (38) stmt -> . IF LRB exp RRB stmt elseiflist
    (39) stmt -> . IF LRB exp RRB stmt elseiflist ELSE stmt
    (40) stmt -> . PRINT LRB ID RRB SEMICOLON
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (27) block -> . LCB varlist stmtlist RCB
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    RETURN          shift and go to state 90
    WHILE           shift and go to state 93
    FOR             shift and go to state 94
    IF              shift and go to state 95
    PRINT           shift and go to state 96
    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    LCB             shift and go to state 45
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 91
    stmt                           shift and go to state 119
    block                          shift and go to state 92
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 116

    (37) stmt -> FOR LRB exp SEMICOLON . exp SEMICOLON exp RRB stmt
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 120
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 117

    (38) stmt -> IF LRB exp RRB . stmt elseiflist
    (39) stmt -> IF LRB exp RRB . stmt elseiflist ELSE stmt
    (33) stmt -> . RETURN exp SEMICOLON
    (34) stmt -> . exp SEMICOLON
    (35) stmt -> . block
    (36) stmt -> . WHILE LRB exp RRB stmt
    (37) stmt -> . FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt
    (38) stmt -> . IF LRB exp RRB stmt elseiflist
    (39) stmt -> . IF LRB exp RRB stmt elseiflist ELSE stmt
    (40) stmt -> . PRINT LRB ID RRB SEMICOLON
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (27) block -> . LCB varlist stmtlist RCB
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    RETURN          shift and go to state 90
    WHILE           shift and go to state 93
    FOR             shift and go to state 94
    IF              shift and go to state 95
    PRINT           shift and go to state 96
    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    LCB             shift and go to state 45
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 91
    stmt                           shift and go to state 121
    block                          shift and go to state 92
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 118

    (40) stmt -> PRINT LRB ID RRB . SEMICOLON

    SEMICOLON       shift and go to state 122


state 119

    (36) stmt -> WHILE LRB exp RRB stmt .

    RCB             reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    RETURN          reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    WHILE           reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    FOR             reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    IF              reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    PRINT           reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    ID              reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    LRB             reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    SUB             reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    NOT             reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    LCB             reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    INTEGERNUMBER   reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    FLOATNUMBER     reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    TRUE            reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    FALSE           reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    ELIF            reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)
    ELSE            reduce using rule 36 (stmt -> WHILE LRB exp RRB stmt .)


state 120

    (37) stmt -> FOR LRB exp SEMICOLON exp . SEMICOLON exp RRB stmt
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    SEMICOLON       shift and go to state 123
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 121

    (38) stmt -> IF LRB exp RRB stmt . elseiflist
    (39) stmt -> IF LRB exp RRB stmt . elseiflist ELSE stmt
    (41) elseiflist -> . ELIF LRB exp RRB stmt
    (42) elseiflist -> . elseiflist ELIF LRB exp RRB stmt
    (43) elseiflist -> .

  ! shift/reduce conflict for ELIF resolved as shift
    ELIF            shift and go to state 125
    RCB             reduce using rule 43 (elseiflist -> .)
    RETURN          reduce using rule 43 (elseiflist -> .)
    WHILE           reduce using rule 43 (elseiflist -> .)
    FOR             reduce using rule 43 (elseiflist -> .)
    IF              reduce using rule 43 (elseiflist -> .)
    PRINT           reduce using rule 43 (elseiflist -> .)
    ID              reduce using rule 43 (elseiflist -> .)
    LRB             reduce using rule 43 (elseiflist -> .)
    SUB             reduce using rule 43 (elseiflist -> .)
    NOT             reduce using rule 43 (elseiflist -> .)
    LCB             reduce using rule 43 (elseiflist -> .)
    INTEGERNUMBER   reduce using rule 43 (elseiflist -> .)
    FLOATNUMBER     reduce using rule 43 (elseiflist -> .)
    TRUE            reduce using rule 43 (elseiflist -> .)
    FALSE           reduce using rule 43 (elseiflist -> .)
    ELSE            reduce using rule 43 (elseiflist -> .)

  ! ELIF            [ reduce using rule 43 (elseiflist -> .) ]

    elseiflist                     shift and go to state 124

state 122

    (40) stmt -> PRINT LRB ID RRB SEMICOLON .

    RCB             reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    RETURN          reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    WHILE           reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    FOR             reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    IF              reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    PRINT           reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    ID              reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    LRB             reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    SUB             reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    NOT             reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    LCB             reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    INTEGERNUMBER   reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    FLOATNUMBER     reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    TRUE            reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    FALSE           reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    ELIF            reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)
    ELSE            reduce using rule 40 (stmt -> PRINT LRB ID RRB SEMICOLON .)


state 123

    (37) stmt -> FOR LRB exp SEMICOLON exp SEMICOLON . exp RRB stmt
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 126
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 124

    (38) stmt -> IF LRB exp RRB stmt elseiflist .
    (39) stmt -> IF LRB exp RRB stmt elseiflist . ELSE stmt
    (42) elseiflist -> elseiflist . ELIF LRB exp RRB stmt

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for ELIF resolved as shift
    RCB             reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    RETURN          reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    WHILE           reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    FOR             reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    IF              reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    PRINT           reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    ID              reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    LRB             reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    SUB             reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    NOT             reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    LCB             reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    INTEGERNUMBER   reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    FLOATNUMBER     reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    TRUE            reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    FALSE           reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .)
    ELSE            shift and go to state 127
    ELIF            shift and go to state 128

  ! ELIF            [ reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .) ]
  ! ELSE            [ reduce using rule 38 (stmt -> IF LRB exp RRB stmt elseiflist .) ]


state 125

    (41) elseiflist -> ELIF . LRB exp RRB stmt

    LRB             shift and go to state 129


state 126

    (37) stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp . RRB stmt
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    RRB             shift and go to state 130
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 127

    (39) stmt -> IF LRB exp RRB stmt elseiflist ELSE . stmt
    (33) stmt -> . RETURN exp SEMICOLON
    (34) stmt -> . exp SEMICOLON
    (35) stmt -> . block
    (36) stmt -> . WHILE LRB exp RRB stmt
    (37) stmt -> . FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt
    (38) stmt -> . IF LRB exp RRB stmt elseiflist
    (39) stmt -> . IF LRB exp RRB stmt elseiflist ELSE stmt
    (40) stmt -> . PRINT LRB ID RRB SEMICOLON
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (27) block -> . LCB varlist stmtlist RCB
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    RETURN          shift and go to state 90
    WHILE           shift and go to state 93
    FOR             shift and go to state 94
    IF              shift and go to state 95
    PRINT           shift and go to state 96
    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    LCB             shift and go to state 45
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 91
    stmt                           shift and go to state 131
    block                          shift and go to state 92
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 128

    (42) elseiflist -> elseiflist ELIF . LRB exp RRB stmt

    LRB             shift and go to state 132


state 129

    (41) elseiflist -> ELIF LRB . exp RRB stmt
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 133
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 130

    (37) stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB . stmt
    (33) stmt -> . RETURN exp SEMICOLON
    (34) stmt -> . exp SEMICOLON
    (35) stmt -> . block
    (36) stmt -> . WHILE LRB exp RRB stmt
    (37) stmt -> . FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt
    (38) stmt -> . IF LRB exp RRB stmt elseiflist
    (39) stmt -> . IF LRB exp RRB stmt elseiflist ELSE stmt
    (40) stmt -> . PRINT LRB ID RRB SEMICOLON
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (27) block -> . LCB varlist stmtlist RCB
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    RETURN          shift and go to state 90
    WHILE           shift and go to state 93
    FOR             shift and go to state 94
    IF              shift and go to state 95
    PRINT           shift and go to state 96
    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    LCB             shift and go to state 45
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 91
    stmt                           shift and go to state 134
    block                          shift and go to state 92
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 131

    (39) stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .

    RCB             reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    RETURN          reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    WHILE           reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    FOR             reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    IF              reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    PRINT           reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    ID              reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    LRB             reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    SUB             reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    NOT             reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    LCB             reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    INTEGERNUMBER   reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    FLOATNUMBER     reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    TRUE            reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    FALSE           reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    ELIF            reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)
    ELSE            reduce using rule 39 (stmt -> IF LRB exp RRB stmt elseiflist ELSE stmt .)


state 132

    (42) elseiflist -> elseiflist ELIF LRB . exp RRB stmt
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 135
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 133

    (41) elseiflist -> ELIF LRB exp . RRB stmt
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    RRB             shift and go to state 136
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 134

    (37) stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .

    RCB             reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    RETURN          reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    WHILE           reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    FOR             reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    IF              reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    PRINT           reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    ID              reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    LRB             reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    SUB             reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    NOT             reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    LCB             reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    INTEGERNUMBER   reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    FLOATNUMBER     reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    TRUE            reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    FALSE           reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    ELIF            reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)
    ELSE            reduce using rule 37 (stmt -> FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt .)


state 135

    (42) elseiflist -> elseiflist ELIF LRB exp . RRB stmt
    (45) exp -> exp . operator exp
    (46) exp -> exp . relop exp
    (54) operator -> . OR
    (55) operator -> . AND
    (56) operator -> . SUM
    (57) operator -> . SUB
    (58) operator -> . MUL
    (59) operator -> . DIV
    (60) operator -> . MOD
    (65) relop -> . GT
    (66) relop -> . LT
    (67) relop -> . NE
    (68) relop -> . EQ
    (69) relop -> . LE
    (70) relop -> . GE

    RRB             shift and go to state 137
    OR              shift and go to state 54
    AND             shift and go to state 55
    SUM             shift and go to state 56
    SUB             shift and go to state 57
    MUL             shift and go to state 58
    DIV             shift and go to state 59
    MOD             shift and go to state 60
    GT              shift and go to state 61
    LT              shift and go to state 62
    NE              shift and go to state 63
    EQ              shift and go to state 64
    LE              shift and go to state 65
    GE              shift and go to state 66

    operator                       shift and go to state 52
    relop                          shift and go to state 53

state 136

    (41) elseiflist -> ELIF LRB exp RRB . stmt
    (33) stmt -> . RETURN exp SEMICOLON
    (34) stmt -> . exp SEMICOLON
    (35) stmt -> . block
    (36) stmt -> . WHILE LRB exp RRB stmt
    (37) stmt -> . FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt
    (38) stmt -> . IF LRB exp RRB stmt elseiflist
    (39) stmt -> . IF LRB exp RRB stmt elseiflist ELSE stmt
    (40) stmt -> . PRINT LRB ID RRB SEMICOLON
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (27) block -> . LCB varlist stmtlist RCB
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    RETURN          shift and go to state 90
    WHILE           shift and go to state 93
    FOR             shift and go to state 94
    IF              shift and go to state 95
    PRINT           shift and go to state 96
    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    LCB             shift and go to state 45
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 91
    stmt                           shift and go to state 138
    block                          shift and go to state 92
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 137

    (42) elseiflist -> elseiflist ELIF LRB exp RRB . stmt
    (33) stmt -> . RETURN exp SEMICOLON
    (34) stmt -> . exp SEMICOLON
    (35) stmt -> . block
    (36) stmt -> . WHILE LRB exp RRB stmt
    (37) stmt -> . FOR LRB exp SEMICOLON exp SEMICOLON exp RRB stmt
    (38) stmt -> . IF LRB exp RRB stmt elseiflist
    (39) stmt -> . IF LRB exp RRB stmt elseiflist ELSE stmt
    (40) stmt -> . PRINT LRB ID RRB SEMICOLON
    (44) exp -> . lvalue ASSIGN exp
    (45) exp -> . exp operator exp
    (46) exp -> . exp relop exp
    (47) exp -> . const
    (48) exp -> . lvalue
    (49) exp -> . ID LRB explist RRB
    (50) exp -> . LRB exp RRB
    (51) exp -> . ID LRB RRB
    (52) exp -> . SUB exp
    (53) exp -> . NOT exp
    (27) block -> . LCB varlist stmtlist RCB
    (31) lvalue -> . ID
    (32) lvalue -> . ID LSB exp RSB
    (61) const -> . INTEGERNUMBER
    (62) const -> . FLOATNUMBER
    (63) const -> . TRUE
    (64) const -> . FALSE

    RETURN          shift and go to state 90
    WHILE           shift and go to state 93
    FOR             shift and go to state 94
    IF              shift and go to state 95
    PRINT           shift and go to state 96
    ID              shift and go to state 31
    LRB             shift and go to state 35
    SUB             shift and go to state 36
    NOT             shift and go to state 37
    LCB             shift and go to state 45
    INTEGERNUMBER   shift and go to state 38
    FLOATNUMBER     shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 91
    stmt                           shift and go to state 139
    block                          shift and go to state 92
    lvalue                         shift and go to state 33
    const                          shift and go to state 34

state 138

    (41) elseiflist -> ELIF LRB exp RRB stmt .

    RCB             reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    RETURN          reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    WHILE           reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    FOR             reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    IF              reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    PRINT           reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    ID              reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    LRB             reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    SUB             reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    NOT             reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    LCB             reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    INTEGERNUMBER   reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    FLOATNUMBER     reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    TRUE            reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    FALSE           reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    ELIF            reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)
    ELSE            reduce using rule 41 (elseiflist -> ELIF LRB exp RRB stmt .)


state 139

    (42) elseiflist -> elseiflist ELIF LRB exp RRB stmt .

    RCB             reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    RETURN          reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    WHILE           reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    FOR             reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    IF              reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    PRINT           reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    ID              reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    LRB             reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    SUB             reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    NOT             reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    LCB             reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    INTEGERNUMBER   reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    FLOATNUMBER     reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    TRUE            reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    FALSE           reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    ELIF            reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)
    ELSE            reduce using rule 42 (elseiflist -> elseiflist ELIF LRB exp RRB stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VOID in state 0 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 0 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 45 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 45 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 45 resolved as shift
WARNING: shift/reduce conflict for OR in state 70 resolved as shift
WARNING: shift/reduce conflict for AND in state 70 resolved as shift
WARNING: shift/reduce conflict for SUM in state 70 resolved as shift
WARNING: shift/reduce conflict for SUB in state 70 resolved as shift
WARNING: shift/reduce conflict for MUL in state 70 resolved as shift
WARNING: shift/reduce conflict for DIV in state 70 resolved as shift
WARNING: shift/reduce conflict for MOD in state 70 resolved as shift
WARNING: shift/reduce conflict for GT in state 70 resolved as shift
WARNING: shift/reduce conflict for LT in state 70 resolved as shift
WARNING: shift/reduce conflict for NE in state 70 resolved as shift
WARNING: shift/reduce conflict for EQ in state 70 resolved as shift
WARNING: shift/reduce conflict for LE in state 70 resolved as shift
WARNING: shift/reduce conflict for GE in state 70 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 72 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 72 resolved as shift
WARNING: shift/reduce conflict for FOR in state 72 resolved as shift
WARNING: shift/reduce conflict for IF in state 72 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 72 resolved as shift
WARNING: shift/reduce conflict for ID in state 72 resolved as shift
WARNING: shift/reduce conflict for LRB in state 72 resolved as shift
WARNING: shift/reduce conflict for SUB in state 72 resolved as shift
WARNING: shift/reduce conflict for NOT in state 72 resolved as shift
WARNING: shift/reduce conflict for LCB in state 72 resolved as shift
WARNING: shift/reduce conflict for INTEGERNUMBER in state 72 resolved as shift
WARNING: shift/reduce conflict for FLOATNUMBER in state 72 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 72 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 72 resolved as shift
WARNING: shift/reduce conflict for OR in state 82 resolved as shift
WARNING: shift/reduce conflict for AND in state 82 resolved as shift
WARNING: shift/reduce conflict for SUM in state 82 resolved as shift
WARNING: shift/reduce conflict for SUB in state 82 resolved as shift
WARNING: shift/reduce conflict for MUL in state 82 resolved as shift
WARNING: shift/reduce conflict for DIV in state 82 resolved as shift
WARNING: shift/reduce conflict for MOD in state 82 resolved as shift
WARNING: shift/reduce conflict for GT in state 82 resolved as shift
WARNING: shift/reduce conflict for LT in state 82 resolved as shift
WARNING: shift/reduce conflict for NE in state 82 resolved as shift
WARNING: shift/reduce conflict for EQ in state 82 resolved as shift
WARNING: shift/reduce conflict for LE in state 82 resolved as shift
WARNING: shift/reduce conflict for GE in state 82 resolved as shift
WARNING: shift/reduce conflict for OR in state 83 resolved as shift
WARNING: shift/reduce conflict for AND in state 83 resolved as shift
WARNING: shift/reduce conflict for SUM in state 83 resolved as shift
WARNING: shift/reduce conflict for SUB in state 83 resolved as shift
WARNING: shift/reduce conflict for MUL in state 83 resolved as shift
WARNING: shift/reduce conflict for DIV in state 83 resolved as shift
WARNING: shift/reduce conflict for MOD in state 83 resolved as shift
WARNING: shift/reduce conflict for GT in state 83 resolved as shift
WARNING: shift/reduce conflict for LT in state 83 resolved as shift
WARNING: shift/reduce conflict for NE in state 83 resolved as shift
WARNING: shift/reduce conflict for EQ in state 83 resolved as shift
WARNING: shift/reduce conflict for LE in state 83 resolved as shift
WARNING: shift/reduce conflict for GE in state 83 resolved as shift
WARNING: shift/reduce conflict for OR in state 84 resolved as shift
WARNING: shift/reduce conflict for AND in state 84 resolved as shift
WARNING: shift/reduce conflict for SUM in state 84 resolved as shift
WARNING: shift/reduce conflict for SUB in state 84 resolved as shift
WARNING: shift/reduce conflict for MUL in state 84 resolved as shift
WARNING: shift/reduce conflict for DIV in state 84 resolved as shift
WARNING: shift/reduce conflict for MOD in state 84 resolved as shift
WARNING: shift/reduce conflict for GT in state 84 resolved as shift
WARNING: shift/reduce conflict for LT in state 84 resolved as shift
WARNING: shift/reduce conflict for NE in state 84 resolved as shift
WARNING: shift/reduce conflict for EQ in state 84 resolved as shift
WARNING: shift/reduce conflict for LE in state 84 resolved as shift
WARNING: shift/reduce conflict for GE in state 84 resolved as shift
WARNING: shift/reduce conflict for ELIF in state 121 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 124 resolved as shift
WARNING: shift/reduce conflict for ELIF in state 124 resolved as shift
